/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/define.ts":
/*!***********************!*\
  !*** ./src/define.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EDGE_WIDTH = exports.NODE_RADIUS = exports.CANVAS_WIDTH = exports.CANVAS_HEIGHT = void 0;\nexports.CANVAS_HEIGHT = 500, exports.CANVAS_WIDTH = 500;\nexports.NODE_RADIUS = 10, exports.EDGE_WIDTH = 5;\n\n\n//# sourceURL=webpack://game_graph/./src/define.ts?");

/***/ }),

/***/ "./src/graph.ts":
/*!**********************!*\
  !*** ./src/graph.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Graph = exports.GraphEdge = exports.GraphNode = void 0;\nconst define = __importStar(__webpack_require__(/*! ./define */ \"./src/define.ts\"));\n/**\n * 図形の基本クラス。\n * 継承先で描画処理を実装する。\n */\nclass Shape {\n    /** 図形の描画を行うメソッド（オーバーライド前提） */\n    draw() { }\n    ;\n}\n/**\n * グラフ上の頂点を表すクラス。\n */\nclass GraphNode extends Shape {\n    /**\n     * 頂点のインスタンスを生成する。\n     * @param {CanvasRenderingContext2D} ctx 描画に使用するCanvasのコンテキスト\n     * @param {number} cx 頂点のX座標\n     * @param {number} cy 頂点のY座標\n     * @param {number} id 頂点の識別子\n     */\n    constructor(ctx, cx, cy, id) {\n        super();\n        this.fill_color = \"black\";\n        this.ctx = ctx;\n        this.center_x = cx;\n        this.center_y = cy;\n        this.id = id;\n    }\n    /**\n     * 頂点の現在位置を返す。\n     * @returns {[number, number]} [x, y] 形式の座標\n     */\n    getPos() { return [this.center_x, this.center_y]; }\n    /**\n     * 指定座標との距離を返す。\n     * @param {number} x 対象X座標\n     * @param {number} y 対象Y座標\n     * @returns {number} ユークリッド距離\n     */\n    getDist(x, y) {\n        return Math.sqrt((this.center_x - x) ** 2 + (y - this.center_y) ** 2);\n    }\n    /**\n     * 頂点の塗りつぶし色を変更する。\n     * @param {\"black\" | \"red\"} c 色（\"black\" または \"red\"）\n     */\n    setFillColor(c) {\n        this.fill_color = c;\n    }\n    /**\n     * 頂点の位置を設定する。\n     * @param {number} x 新しいX座標\n     * @param {number} y 新しいY座標\n     */\n    setPos(x, y) {\n        this.center_x = x;\n        this.center_y = y;\n    }\n    /**\n     * ノードをキャンバスに描画する。\n     */\n    draw() {\n        this.ctx.beginPath();\n        this.ctx.arc(this.center_x, this.center_y, define.NODE_RADIUS, 0, 2 * Math.PI);\n        this.ctx.fillStyle = this.fill_color;\n        this.ctx.fill();\n        this.ctx.closePath();\n    }\n}\nexports.GraphNode = GraphNode;\n;\nclass GraphEdge extends Shape {\n    /**\n     * 辺のインスタンスを生成する。\n     * @param {CanvasRenderingContext2D} ctx 描画に使用するCanvasのコンテキスト\n     * @param {number} node1 辺の始点ノード\n     * @param {number} node2 辺の終点ノード\n     */\n    constructor(ctx, n1, n2) {\n        super();\n        this.color = \"black\";\n        this.ctx = ctx;\n        this.node1 = n1;\n        this.node2 = n2;\n    }\n    /**\n     * 辺の色を設定する。\n     * @param {\"black\" | \"red\" | \"yellow\"} color 色（\"black\" または \"red\" または \"yellow\"）\n     */\n    setColor(c) { this.color = c; }\n    /**\n     * 辺をキャンバスに描画する。\n     */\n    draw() {\n        const lineWidth = this.ctx.lineWidth;\n        const pre_color = this.ctx.strokeStyle;\n        const [x1, y1] = this.node1.getPos(), [x2, y2] = this.node2.getPos();\n        this.ctx.lineWidth = define.EDGE_WIDTH;\n        this.ctx.strokeStyle = this.color;\n        this.ctx.beginPath();\n        this.ctx.moveTo(x1, y1);\n        this.ctx.lineTo(x2, y2);\n        this.ctx.stroke();\n        this.ctx.closePath();\n        this.ctx.lineWidth = lineWidth;\n        this.ctx.strokeStyle = pre_color;\n    }\n    /**\n     * 与えられた辺との交差を判定する。\n     * @param {GraphEdge} edge 判定する辺\n     * @returns {bool} 交差しているかどうか\n     */\n    checkCrossed(edge) {\n        // https://qiita.com/zu_rin/items/e04fdec4e3dec6072104\n        const [a1x, a1y] = this.node1.getPos();\n        const [a2x, a2y] = this.node2.getPos();\n        const [b1x, b1y] = edge.node1.getPos();\n        const [b2x, b2y] = edge.node2.getPos();\n        const s1 = (a1x - a2x) * (b1y - a1y) - (a1y - a2y) * (b1x - a1x);\n        const t1 = (a1x - a2x) * (b2y - a1y) - (a1y - a2y) * (b2x - a1x);\n        if (s1 * t1 > 0)\n            return false;\n        const s2 = (b1x - b2x) * (a1y - b1y) - (b1y - b2y) * (a1x - b1x);\n        const t2 = (b1x - b2x) * (a2y - b1y) - (b1y - b2y) * (a2x - b1x);\n        if (s2 * t2 > 0)\n            return false;\n        return true;\n    }\n    /**\n     * 辺が隣接するかどうかを判定する。\n     * @param {GraphEdge} edge 判定する辺\n     * @returns {bool} 隣接しているかどうか\n     */\n    checkNeighbor(edge) {\n        return this.node1 == edge.node1 || this.node1 == edge.node2 || this.node2 == edge.node1 || this.node2 == edge.node2;\n    }\n}\nexports.GraphEdge = GraphEdge;\n;\nclass Graph {\n    /**\n     * グラフ操作用のインスタンスを生成する。\n     * @param {CanvasRenderingContext2D} ctx 描画に使用するCanvasのコンテキスト\n     */\n    constructor(ctx) {\n        this.graphNodes = [];\n        this.graphEdges = [];\n        this.ctx = ctx;\n    }\n    /**\n     * 頂点のみを取得する。\n     * @returns {GraphNode[]} GraphNodeの配列\n     */\n    getNodes() { return this.graphNodes; }\n    /**\n     * Canvasのコンテキストを返す。\n     * @returns {CanvasRenderingContext2D} Canvasのコンテキスト\n     */\n    getCtx() { return this.ctx; }\n    /**\n     * グラフ要素を追加する。\n     * @param {Shape} elem ノードまたは辺\n     */\n    addGraphElement(e) {\n        if (e instanceof GraphNode)\n            this.graphNodes.push(e);\n        else if (e instanceof GraphEdge)\n            this.graphEdges.push(e);\n    }\n    /**\n     * 辺の色を更新（交差に応じて赤色に）\n     */\n    updateEdgeColor() {\n        const crossed = this.checkCrossedEdges();\n        const len = this.graphEdges.length;\n        let crossed_graph = false;\n        for (let i = 0; i < len; i++) {\n            this.graphEdges[i].setColor(crossed[i] ? \"red\" : \"black\");\n            crossed_graph || (crossed_graph = crossed[i]);\n        }\n        return crossed_graph;\n    }\n    /**\n     * グラフが交差していないか判定する。\n     * @returns {boolean} 全ての辺が交差していなければ true\n     */\n    checkCrossedGraph() {\n        const crossed = this.checkCrossedEdges();\n        return !(crossed.every((e) => !e));\n    }\n    /**\n     * 各辺について隣接した辺以外と交差しているかを判定する。\n     * @returns {boolean[]} 辺が交差しているかの結果\n     */\n    checkCrossedEdges() {\n        const len = this.graphEdges.length;\n        let crossed = Array(len).fill(false);\n        for (let i = 0; i < len; i++)\n            for (let j = i + 1; j < len; j++) {\n                if (this.graphEdges[i].checkNeighbor(this.graphEdges[j]))\n                    continue;\n                if (this.graphEdges[i].checkCrossed(this.graphEdges[j])) {\n                    crossed[i] = true;\n                    crossed[j] = true;\n                }\n            }\n        return crossed;\n    }\n    /**\n     * グラフを描画する。\n     */\n    draw() {\n        this.ctx.clearRect(0, 0, define.CANVAS_HEIGHT, define.CANVAS_WIDTH);\n        for (const e of this.graphEdges)\n            e.draw();\n        for (const e of this.graphNodes)\n            e.draw();\n    }\n    /**\n     * 与えられた座標に最も近い頂点を取得する。\n     * @param {number} x x座標\n     * @param {number} y y座標\n     * @returns {GraphNode | null} 最も近い頂点 頂点がなければnull\n     */\n    getClosestNode(x, y) {\n        let min_dist = Infinity;\n        let closest_node = null;\n        for (const node of this.graphNodes) {\n            const dist = node.getDist(x, y);\n            console.log(`${node.id} ${dist}`);\n            if (min_dist > dist) {\n                min_dist = dist;\n                closest_node = node;\n            }\n        }\n        return closest_node;\n    }\n    /**\n     * グラフクリア時の描画処理を行う。\n     */\n    drawClearedGraph() {\n        for (const edge of this.graphEdges)\n            edge.setColor(\"yellow\");\n        console.log(\"fin\");\n        this.draw();\n    }\n}\nexports.Graph = Graph;\n;\n\n\n//# sourceURL=webpack://game_graph/./src/graph.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst graph = __importStar(__webpack_require__(/*! ./graph */ \"./src/graph.ts\"));\nconst define = __importStar(__webpack_require__(/*! ./define */ \"./src/define.ts\"));\nconst controller = new AbortController();\nconst signal = controller.signal;\nconst body = document.getElementsByTagName(\"body\")[0];\n// キャンバスを取得\nconst gameScreen = document.getElementById(\"game_screen\");\nconst textInfo = document.getElementById(\"info\");\ndocument.addEventListener(\"DOMContentLoaded\", initialize);\n/**\n * ページ読み込み時の初期化関数。\n * キャンバスの設定・グラフの描画・イベント登録を行う。\n */\nfunction initialize() {\n    // キャンバスの描画用オブジェクトを取得\n    const ctx = gameScreen.getContext(\"2d\");\n    // キャンバスの大きさを設定\n    gameScreen.height = define.CANVAS_HEIGHT;\n    gameScreen.width = define.CANVAS_WIDTH;\n    // 初期描画\n    const opeg = new graph.Graph(ctx);\n    createPlanegraph(opeg, 15); // 平面グラフを作成\n    opeg.updateEdgeColor(); // 辺の交差情報を更新\n    opeg.draw(); // 全ての要素を描画\n    // キャンバスなどにマウスイベントを設定\n    settingCanvasEvent(opeg);\n}\n/**\n * キャンバス上のマウス操作イベントを設定する。\n * 頂点の選択やドラッグによる移動などを制御する。\n * @param {graph.Graph} opeg グラフ操作オブジェクト\n */\nfunction settingCanvasEvent(opeg) {\n    let isDragging = false;\n    let mouseStartX, mouseStartY;\n    let nodeStartX, nodeStartY;\n    let operatedNode;\n    gameScreen.addEventListener(\"mousedown\", (e) => {\n        const rect = gameScreen.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        mouseStartX = x;\n        mouseStartY = y;\n        operatedNode = opeg.getClosestNode(x, y);\n        operatedNode === null || operatedNode === void 0 ? void 0 : operatedNode.setFillColor(\"red\");\n        operatedNode === null || operatedNode === void 0 ? void 0 : operatedNode.draw();\n        const pos = operatedNode === null || operatedNode === void 0 ? void 0 : operatedNode.getPos();\n        if (pos != undefined) {\n            nodeStartX = pos[0];\n            nodeStartY = pos[1];\n        }\n        isDragging = true;\n    }, { signal: signal });\n    body.addEventListener(\"mousemove\", (e) => {\n        if (!isDragging)\n            return;\n        const rect = gameScreen.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        const processed_x = Math.min(Math.max(x - mouseStartX + nodeStartX, define.NODE_RADIUS), define.CANVAS_WIDTH - define.NODE_RADIUS);\n        const processed_y = Math.min(Math.max(y - mouseStartY + nodeStartY, define.NODE_RADIUS), define.CANVAS_HEIGHT - define.NODE_RADIUS);\n        operatedNode === null || operatedNode === void 0 ? void 0 : operatedNode.setPos(processed_x, processed_y);\n        opeg.updateEdgeColor();\n        opeg.draw();\n    });\n    body.addEventListener(\"mouseup\", (e) => {\n        if (!isDragging)\n            return;\n        operatedNode === null || operatedNode === void 0 ? void 0 : operatedNode.setFillColor(\"black\");\n        operatedNode === null || operatedNode === void 0 ? void 0 : operatedNode.draw();\n        isDragging = false;\n        if (!opeg.checkCrossedGraph()) {\n            finishGame(opeg);\n        }\n    });\n}\n/**\n * 平面グラフを構成する頂点と辺を作成する。\n * @param {graph.Graph} opeg グラフ操作オブジェクト\n * @param {number} cntNode 作成する頂点の数\n */\nfunction createPlanegraph(opeg, cntNode) {\n    const ctx = opeg.getCtx();\n    // 頂点を作成\n    const CNT_NODE = cntNode;\n    let preNode = null;\n    for (let i = 0; i < CNT_NODE; i++) {\n        let x = Math.random() * 460 + 20;\n        let y = Math.random() * 460 + 20;\n        const node = new graph.GraphNode(ctx, x, y, i);\n        opeg.addGraphElement(node);\n        if (getRandint(0, 2) == 0 && preNode != null) {\n            opeg.addGraphElement(new graph.GraphEdge(ctx, preNode, node));\n        }\n        preNode = node;\n    }\n    // 辺を作成\n    const nodes = opeg.getNodes();\n    const edges = createPlanegraphEdges(CNT_NODE);\n    for (const edge of edges) {\n        opeg.addGraphElement(new graph.GraphEdge(ctx, nodes[edge[0]], nodes[edge[1]]));\n    }\n    textInfo.innerText = `node:${CNT_NODE} edge:${edges.length}`;\n}\n/**\n * 平面グラフの辺をランダムに生成する。\n * @param {number} cntNode 頂点数\n * @returns {[number, number][]} 有効な辺のリスト\n */\nfunction createPlanegraphEdges(cntNode) {\n    let edgesLeft = [], edgesRight = [];\n    let cntFail = 0;\n    while (cntFail < 1000) {\n        const addLeft = getRandint(0, 2) == 0;\n        const start = getRandint(0, cntNode - 2);\n        const end = getRandint(start + 2, cntNode);\n        const newEdge = [start, end];\n        if (addLeft && checkCrossing(edgesLeft, newEdge))\n            edgesLeft.push(newEdge);\n        else if (checkCrossing(edgesRight, newEdge))\n            edgesRight.push(newEdge);\n        else {\n            cntFail++;\n            continue;\n        }\n        cntFail = 0;\n    }\n    console.log(edgesLeft.sort());\n    console.log(\"-----\");\n    console.log(edgesRight.sort());\n    const all_edges = edgesLeft.concat(edgesRight);\n    return all_edges;\n}\n/**\n * 新たな辺を追加したときの交差判定を行う。\n * @param {[number, number][]} existedEdges 既存の辺集合\n * @param {[number, number]} newEdge 新たに追加する辺\n * @returns {boolean} 交差が起こるかどうか\n */\nfunction checkCrossing(existedEdges, newEdge) {\n    for (const edge of existedEdges) {\n        const inside = edge[0] <= newEdge[0] && newEdge[1] <= edge[1];\n        const outside = newEdge[0] <= edge[0] && edge[1] <= newEdge[1];\n        const equal = newEdge[0] == edge[0] && edge[1] == newEdge[1];\n        if (equal || !(inside || outside))\n            return false;\n    }\n    return true;\n}\n/**\n * 指定した範囲の整数をランダムに生成する。\n * [start, end)の範囲。\n * @param {number} start 範囲の始まり（含む）\n * @param {number} end 範囲の終わり（含まない）\n * @returns ランダムな整数\n */\nfunction getRandint(start, end) {\n    if (start > end) {\n        const tmp = start;\n        start = end;\n        end = tmp;\n    }\n    return Math.floor(Math.random() * (end - start)) + start;\n}\n/**\n * ゲーム終了時の処理を行う。\n * @param {graph.Graph} opeg グラフ操作オブジェクト\n */\nfunction finishGame(opeg) {\n    // イベントリスナを削除\n    controller.abort();\n    opeg.drawClearedGraph();\n    textInfo.innerText = \"CLEAR!\";\n}\n\n\n//# sourceURL=webpack://game_graph/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;